/* 
{{.AutogeneratedNotice}}

*/
package {{.PackageName}}

import (
	"context"
	"encoding/json"
	"fmt"
	
	"{{.WeaviatePackage}}/weaviate"
	"{{.WeaviatePackage}}/weaviate/graphql"
	"{{.WeaviatePackage}}/weaviate/filters"
)

{{ with .Data }}

// {{.ClassName}}CRUD provides CRUD operations for the {{.ClassName}} class
type {{.ClassName}}CRUD struct {
	client *Client

	fields []graphql.Field
}

// New{{.ClassName}}CRUD creates a new CRUD handler for {{.ClassName}}
func (c *Client) {{.ClassName}}CRUD() *{{.ClassName}}CRUD {
	return &{{.ClassName}}CRUD{
		client: c,
		fields: []graphql.Field{
			{{ range .Properties -}}
			{Name: "{{.Name}}"},
			{{end}}
		},
	}
}

// Create adds a new {{.ClassName}} object to Weaviate
func (c *{{.ClassName}}CRUD) Create(ctx context.Context, obj {{.ClassName}}) (string, error) {
	// Create a unique ID if not provided
	id := obj.{{.IDField}}
	if id == "" {
		// Generate UUID
		id = weaviate.GenerateUUID()
	}
	
	// Create the object
	_, err := c.creator("{{.ClassName}}", id).
		WithProperties(obj).
		Do(ctx)
	
	if err != nil {
		return "", fmt.Errorf("error creating {{.ClassName}}: %v", err)
	}
	
	return id, nil
}

// Get retrieves a {{.ClassName}} by ID
func (c *{{.ClassName}}CRUD) Get(ctx context.Context, id string) (*{{.ClassName}}, error) {
	
	// Execute the query
	result, err := c.getter("{{.ClassName}}", id).
		WithFields(c.fields...).
		Do(ctx)
	
	if err != nil {
		return nil, fmt.Errorf("error getting {{.ClassName}}: %v", err)
	}
	
	if len(result) == 0 {
		return nil, fmt.Errorf("{{.ClassName}} with ID %s not found", id)
	}
	
	// Convert to struct
	var obj {{.ClassName}}
	objData, err := json.Marshal(result[0].Properties)
	if err != nil {
		return nil, fmt.Errorf("error marshaling {{.ClassName}} properties: %v", err)
	}
	
	if err := json.Unmarshal(objData, &obj); err != nil {
		return nil, fmt.Errorf("error unmarshaling {{.ClassName}}: %v", err)
	}
	
	return &obj, nil
}

// GetByProperty retrieves {{.ClassName}} objects by property value
func (c *{{.ClassName}}CRUD) GetByProperty(ctx context.Context, propertyName, value string) ([]{{.ClassName}}, error) {
	// Build where filter
	where := filters.Where().
		WithPath([]string{propertyName}).
		WithOperator(filters.Equal).
		WithValueString(value)
	
	// Execute the query
	result, err := c.searcher("{{.ClassName}}").
		WithFields(c.fields...).
		WithWhere(where).
		Do(ctx)
	
	if err != nil {
		return nil, fmt.Errorf("error querying {{.ClassName}} by property: %v", err)
	}
	
	// Parse results
	var objs []{{.ClassName}}
	
	// Get data from response
	data, ok := result.Data["Get"].(map[string]interface{})
	if !ok {
		return objs, nil
	}
	
	classData, ok := data["{{.ClassName}}"].([]interface{})
	if !ok {
		return objs, nil
	}
	
	// Convert to structs
	for _, item := range classData {
		itemMap, ok := item.(map[string]interface{})
		if !ok {
			continue
		}
		
		var obj {{.ClassName}}
		objData, err := json.Marshal(itemMap)
		if err != nil {
			return nil, fmt.Errorf("error marshaling {{.ClassName}} item: %v", err)
		}
		
		if err := json.Unmarshal(objData, &obj); err != nil {
			return nil, fmt.Errorf("error unmarshaling {{.ClassName}} item: %v", err)
		}
		
		objs = append(objs, obj)
	}
	
	return objs, nil
}

// Update modifies an existing {{.ClassName}} object
func (c *{{.ClassName}}CRUD) Update(ctx context.Context, id string, obj {{.ClassName}}) error {
	// Update the object
	_, err := c.updater("{{.ClassName}}", id).
		WithProperties(obj).
		Do(ctx)
	
	if err != nil {
		return fmt.Errorf("error updating {{.ClassName}}: %v", err)
	}
	
	return nil
}

// Delete removes a {{.ClassName}} from Weaviate
func (c *{{.ClassName}}CRUD) Delete(ctx context.Context, id string) error {
	err := c.deleter("{{.ClassName}}", id).
		Do(ctx)
	
	if err != nil {
		return fmt.Errorf("error deleting {{.ClassName}}: %v", err)
	}
	
	return nil
}

// Search performs a vector search for {{.ClassName}} objects
func (c *{{.ClassName}}CRUD) Search(ctx context.Context, concept string, limit int) ([]{{.ClassName}}, error) {
	
	// Execute the query
	result, err := c.searcher("{{.ClassName}}").
		WithFields(c.fields...).
		WithNearText(graphql.NearTextArgument{
			Concepts: []string{concept},
			Limit:    limit,
		}).
		Do(ctx)
	
	if err != nil {
		return nil, fmt.Errorf("error searching {{.ClassName}}: %v", err)
	}
	
	// Parse results
	var objs []{{.ClassName}}
	
	// Get data from response
	data, ok := result.Data["Get"].(map[string]interface{})
	if !ok {
		return objs, nil
	}
	
	classData, ok := data["{{.ClassName}}"].([]interface{})
	if !ok {
		return objs, nil
	}
	
	// Convert to structs
	for _, item := range classData {
		itemMap, ok := item.(map[string]interface{})
		if !ok {
			continue
		}
		
		var obj {{.ClassName}}
		objData, err := json.Marshal(itemMap)
		if err != nil {
			return nil, fmt.Errorf("error marshaling {{.ClassName}} search result: %v", err)
		}
		
		if err := json.Unmarshal(objData, &obj); err != nil {
			return nil, fmt.Errorf("error unmarshaling {{.ClassName}} search result: %v", err)
		}
		
		objs = append(objs, obj)
	}
	
	return objs, nil
}

// NearText performs a near-text search for {{.ClassName}} objects
func (c *{{.ClassName}}CRUD) NearText(ctx context.Context, text string, limit int) ([]{{.ClassName}}, error) {
		
	// Execute the query
	result, err := c.searcher("{{.ClassName}}").
		WithFields(c.fields...).
		WithNearText(graphql.NearTextArgument{
			Concepts: []string{text},
			Limit:    limit,
		}).
		Do(ctx)
	
	if err != nil {
		return nil, fmt.Errorf("error performing near-text search for {{.ClassName}}: %v", err)
	}
	
	// Parse results
	var objs []{{.ClassName}}
	
	// Get data from response
	data, ok := result.Data["Get"].(map[string]interface{})
	if !ok {
		return objs, nil
	}
	
	classData, ok := data["{{.ClassName}}"].([]interface{})
	if !ok {
		return objs, nil
	}
	
	// Convert to structs
	for _, item := range classData {
		itemMap, ok := item.(map[string]interface{})
		if !ok {
			continue
		}
		
		var obj {{.ClassName}}
		objData, err := json.Marshal(itemMap)
		if err != nil {
			return nil, fmt.Errorf("error marshaling {{.ClassName}} near-text result: %v", err)
		}
		
		if err := json.Unmarshal(objData, &obj); err != nil {
			return nil, fmt.Errorf("error unmarshaling {{.ClassName}} near-text result: %v", err)
		}
		
		objs = append(objs, obj)
	}
	
	return objs, nil
}

// NearObject performs a near-object search for {{.ClassName}} objects
func (c *{{.ClassName}}CRUD) NearObject(ctx context.Context, id string, limit int) ([]{{.ClassName}}, error) {
	
	// Execute the query
	result, err := c.searcher("{{.ClassName}}").
		WithFields(c.fields...).
		WithNearObject(graphql.NearObjectArgument{
			ID:    id,
			Limit: limit,
		}).
		Do(ctx)
	
	if err != nil {
		return nil, fmt.Errorf("error performing near-object search for {{.ClassName}}: %v", err)
	}
	
	// Parse results
	var objs []{{.ClassName}}
	
	// Get data from response
	data, ok := result.Data["Get"].(map[string]interface{})
	if !ok {
		return objs, nil
	}
	
	classData, ok := data["{{.ClassName}}"].([]interface{})
	if !ok {
		return objs, nil
	}
	
	// Convert to structs
	for _, item := range classData {
		itemMap, ok := item.(map[string]interface{})
		if !ok {
			continue
		}
		
		var obj {{.ClassName}}
		objData, err := json.Marshal(itemMap)
		if err != nil {
			return nil, fmt.Errorf("error marshaling {{.ClassName}} near-object result: %v", err)
		}
		
		if err := json.Unmarshal(objData, &obj); err != nil {
			return nil, fmt.Errorf("error unmarshaling {{.ClassName}} near-object result: %v", err)
		}
		
		objs = append(objs, obj)
	}
	
	return objs, nil
}

{{ end }}
