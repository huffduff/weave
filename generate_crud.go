package weave

import (
	"bytes"
	"embed"
	"fmt"
	"go/format"
	"os"
	"path"
	"path/filepath"
	"strings"
	"text/template"
)

//go:embed templates
var templates embed.FS

type TemplateData[T any] struct {
	AutogeneratedNotice string
	WeaviatePackage     string
	PackageName         string
	Data                T
}

const (
	// WeaviatePackage is the package name for the Weaviate client
	WeaviatePackage = "github.com/weaviate/weaviate-go-client/v5"
)

func findPackageName(schema WeaviateSchemaDefinition, outputDir string) string {
	packageNames := make(map[string]int)
	for _, class := range schema.Classes {
		packageName := strings.ToLower(class.Package)
		packageNames[packageName]++
	}
	if len(packageNames) == 1 {
		for packageName := range packageNames {
			return packageName
		}
	}
	return path.Base(outputDir)
}

// GenerateCRUDCode generates CRUD implementation for all Weaviate classes
// returns the generated package name
func GenerateCRUDCode(schema *WeaviateSchemaDefinition, outputDir string) (string, error) {
	// Create output directory if it doesn't exist
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return "", fmt.Errorf("error creating output directory: %v", err)
	}

	packageName := findPackageName(*schema, outputDir)
	// Generate client code
	if err := generateClientCode(packageName, outputDir); err != nil {
		return packageName, err
	}

	// Generate CRUD implementation for each class
	for _, class := range schema.Classes {
		if err := generateClassCRUD(packageName, class, outputDir); err != nil {
			return packageName, fmt.Errorf("error generating CRUD for class %s: %v", class.Class, err)
		}
	}

	return packageName, nil
}

func generateFromTemplate[T any](src string, data TemplateData[T], filename string) error {
	t, err := templates.ReadFile("templates/" + src + ".tmpl")
	if err != nil {
		return fmt.Errorf("error reading %s template: %v", src, err)
	}
	tmpl, err := template.New(src).Parse(string(t))
	if err != nil {
		return fmt.Errorf("error parsing %s template: %v", src, err)
	}

	fmt.Println("Generating", filename, tmpl)

	data.AutogeneratedNotice = "// Code generated by weave. DO NOT EDIT.\n\n"

	// Execute the template
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("error executing class CRUD template: %v", err)
	}

	// Format the code
	formattedCode, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Println(buf.String())
		return fmt.Errorf("error formatting generated code: %v", err)
	}
	// formattedCode := buf.Bytes()

	// Write the code to file
	if err := os.WriteFile(filename, formattedCode, 0644); err != nil {
		return fmt.Errorf("error writing %s code: %v", src, err)
	}
	return nil
}

// generateClientCode creates the base Weaviate client code
func generateClientCode(packageName string, outputDir string) error {

	templateData := TemplateData[struct{}]{
		PackageName: packageName,
	}

	return generateFromTemplate("client", templateData, filepath.Join(outputDir, "client.go"))
}

// generateClassCRUD generates CRUD code for a specific class
func generateClassCRUD(packageName string, class WeaviateClass, outputDir string) error {
	// Create template data
	idField := "ID" // Default ID field name

	// Find ID field
	for _, prop := range class.Properties {
		if strings.ToLower(prop.Name) == "id" || strings.HasSuffix(strings.ToLower(prop.Name), "_id") {
			// Convert to Go field name format (camelCase to PascalCase)
			idField = toPascalCase(prop.Name)
			break
		}
	}

	type Data struct {
		ClassName  string
		IDField    string
		Properties []struct {
			Name string
		}
	}

	templateData := TemplateData[Data]{
		PackageName:     packageName,
		WeaviatePackage: WeaviatePackage,
		Data: Data{
			ClassName:  class.Class,
			IDField:    idField,
			Properties: []struct{ Name string }{},
		},
	}

	// Add properties
	for _, prop := range class.Properties {
		templateData.Data.Properties = append(templateData.Data.Properties, struct{ Name string }{
			Name: prop.Name,
		})
	}

	return generateFromTemplate("class_crud", templateData, filepath.Join(outputDir, strings.ToLower(class.Class)+"_crud.go"))
}

// toPascalCase converts a string from camelCase or snake_case to PascalCase
func toPascalCase(s string) string {
	// Handle snake_case
	if strings.Contains(s, "_") {
		parts := strings.Split(s, "_")
		for i, part := range parts {
			if len(part) > 0 {
				parts[i] = strings.ToUpper(part[:1]) + part[1:]
			}
		}
		return strings.Join(parts, "")
	}

	// Handle camelCase
	if len(s) > 0 {
		return strings.ToUpper(s[:1]) + s[1:]
	}

	return s
}
